## ARM Assembly

## arithmatic; add

main.c
```c
int main(void) {
  int a = 10;
  int b = 9;
  int c = 15;
  int d;

  d = a + b + c;  // d = 34

  return d;
}
```


Compile
```bash
$ arm-none-eabi-gcc -nostdlib -fomit-frame-pointer -marm -march=armv4 -O0 -S main.c -o main.s
$ arm-none-eabi-as -march=armv4 start.s main.s -o main.o
$ arm-none-eabi-ld -A armv4 -T link.ld main.o -o main.elf
$ arm-none-eabi-objcopy -O binary main.elf main.bin
```

Disassemble
```armasm
0001000c <main>:
   1000c:       e24dd010        sub     sp, sp, #16   @ 4 local variables; 4 x 4 bytes = 16 bytes allocated in the stack
   10010:       e3a0300a        mov     r3, #10       @ int a = 10;
   10014:       e58d300c        str     r3, [sp, #12] @ increate the stack pointer by 4, store the value of variable 'a'.
   10018:       e3a03009        mov     r3, #9        @ int b = 9;
   1001c:       e58d3008        str     r3, [sp, #8]  @ increate the stack pointer by 4, store the value of variable 'b'.
   10020:       e3a0300f        mov     r3, #15       @ int c = 15;
   10024:       e58d3004        str     r3, [sp, #4]  @ increate the stack pointer by 4, store the value of variable 'c'.
   10028:       e59d200c        ldr     r2, [sp, #12] @ get the value of varaible a into the register r2.
   1002c:       e59d3008        ldr     r3, [sp, #8]  @ get the value of varaible b into the register r3.
   10030:       e0822003        add     r2, r2, r3    @ add the value of variable a, 10, and variable b, 9, then store it to register r2.(19)
   10034:       e59d3004        ldr     r3, [sp, #4]  @ get the value of varaible c into the register r3.
   10038:       e0823003        add     r3, r2, r3    @ add the value of c, 15, and register r2, 19, then store it to register r3.(34)
   1003c:       e58d3000        str     r3, [sp]      @ store the registre r3 value(34) into the top of stack(0x10000).
   10040:       e59d3000        ldr     r3, [sp]      @ get it
   10044:       e1a00003        mov     r0, r3        @ register r0 for the statement has 34.
   10048:       e28dd010        add     sp, sp, #16   @ restore the stack pointer that was decreased by 16.
   1004c:       e1a0f00e        mov     pc, lr        @ return to the calle.
```

Debug
```bash
(gdb) target remote :1234
(gdb) break *0x1000c   # start of the main function
(gdb) c
(gdb) i r r3 r2 r0
(gdb) x/1d $sp+12   # int a = 10;
(gdb) x/1d $sp+8    # int b = 9;
(gdb) x/1d $sp+4    # int c = 15;
```

## arithmatic; sub
main.c
```c
int main(void) {
  int a = 10;
  int b = 9;
  int c = 15;
  int d;

  d = a - b + c;  // d = 16

  return d;
}
```

Disassemble
```armasm
0001000c <main>:
   1000c:       e24dd010        sub     sp, sp, #16
   10010:       e3a0300a        mov     r3, #10
   10014:       e58d300c        str     r3, [sp, #12]
   10018:       e3a03009        mov     r3, #9
   1001c:       e58d3008        str     r3, [sp, #8]
   10020:       e3a0300f        mov     r3, #15
   10024:       e58d3004        str     r3, [sp, #4]
   10028:       e59d200c        ldr     r2, [sp, #12]
   1002c:       e59d3008        ldr     r3, [sp, #8]
   10030:       e0422003        sub     r2, r2, r3       @ t = a - b
   10034:       e59d3004        ldr     r3, [sp, #4]
   10038:       e0823003        add     r3, r2, r3       @ d = t + c
   1003c:       e58d3000        str     r3, [sp]
   10040:       e59d3000        ldr     r3, [sp]
   10044:       e1a00003        mov     r0, r3
   10048:       e28dd010        add     sp, sp, #16
   1004c:       e1a0f00e        mov     pc, lr
```


## arithmetic; reverse
```c
int main(void) {
  int a = 10;
  int b = -a;
  int c = -8;
  return b - c;
}
```

```armasm
0001000c <main>:
   1000c:       e24dd010        sub     sp, sp, #16
   10010:       e3a0300a        mov     r3, #10
   10014:       e58d300c        str     r3, [sp, #12]
   10018:       e59d300c        ldr     r3, [sp, #12]
   1001c:       e2633000        rsb     r3, r3, #0      @ int b = -a;
   10020:       e58d3008        str     r3, [sp, #8]
   10024:       e3e03007        mvn     r3, #7          @ int c = -8;
   10028:       e58d3004        str     r3, [sp, #4]
   1002c:       e59d2008        ldr     r2, [sp, #8]
   10030:       e59d3004        ldr     r3, [sp, #4]
   10034:       e0423003        sub     r3, r2, r3
   10038:       e1a00003        mov     r0, r3
   1003c:       e28dd010        add     sp, sp, #16
   10040:       e1a0f00e        mov     pc, lr
```

## conditional
```c
int main(void) {
  int a = 9;
  int b = 0;

  if (a > 5)
    b = 1;
  else if (a == 3)
    b = 2;
  else if (a != 100)
    b = 3;
  else
    b = 4;

  return b;
}
```

```armasm
0001000c <main>:
   @ int a = 9;
   @ int b = 0;
   1000c:       e24dd008        sub     sp, sp, #8
   10010:       e3a03009        mov     r3, #9
   10014:       e58d3000        str     r3, [sp]
   10018:       e3a03000        mov     r3, #0
   1001c:       e58d3004        str     r3, [sp, #4]
   10020:       e59d3000        ldr     r3, [sp]
   @ if (a > 5)
   10024:       e3530005        cmp     r3, #5
   10028:       da000002        ble     10038 <main+0x2c>
   @ b = 1;
   1002c:       e3a03001        mov     r3, #1
   10030:       e58d3004        str     r3, [sp, #4]
   10034:       ea00000d        b       10070 <main+0x64>
   @ else if (a == 3)
   10038:       e59d3000        ldr     r3, [sp]
   1003c:       e3530003        cmp     r3, #3
   10040:       1a000002        bne     10050 <main+0x44>
   @ b = 2;
   10044:       e3a03002        mov     r3, #2
   10048:       e58d3004        str     r3, [sp, #4]
   1004c:       ea000007        b       10070 <main+0x64>
   @ else if (a != 100)
   10050:       e59d3000        ldr     r3, [sp]
   10054:       e3530064        cmp     r3, #100        ; 0x64
   10058:       0a000002        beq     10068 <main+0x5c>
   @ b = 3;
   1005c:       e3a03003        mov     r3, #3
   10060:       e58d3004        str     r3, [sp, #4]
   10064:       ea000001        b       10070 <main+0x64>
   @ else
   @   b = 4;
   10068:       e3a03004        mov     r3, #4
   1006c:       e58d3004        str     r3, [sp, #4]
   @ return b;
   10070:       e59d3004        ldr     r3, [sp, #4]
   10074:       e1a00003        mov     r0, r3
   10078:       e28dd008        add     sp, sp, #8
   1007c:       e1a0f00e        mov     pc, lr
```

## pointer
```c
int main(void) {
  int a = 10;
  int *b = &a;
  int *c = b;
  int *d = c + 1;
  return *c;
}
```

$ arm-none-eabi-gcc -nostdlib -fomit-frame-pointer -marm -march=armv4 -T link.ld -O0 start.s main.c -o main.elf

```armasm
0001000c <main>:
   1000c:       e24dd010        sub     sp, sp, #16
   @ int a = 10;
   10010:       e3a0300a        mov     r3, #10    
   10014:       e58d3000        str     r3, [sp]
   @ int *b = &a;
   10018:       e1a0300d        mov     r3, sp
   1001c:       e58d300c        str     r3, [sp, #12]
   @ int *c = b;
   10020:       e59d300c        ldr     r3, [sp, #12]
   10024:       e58d3008        str     r3, [sp, #8]
   @ int *d = c + 1;
   10028:       e59d3008        ldr     r3, [sp, #8]
   1002c:       e2833004        add     r3, r3, #4
   10030:       e58d3004        str     r3, [sp, #4]
   @ return *c;
   10034:       e59d3008        ldr     r3, [sp, #8]  @ r3 has the address of c
   10038:       e5933000        ldr     r3, [r3]      @ now r3 has the value at the address of the previous r3.
   1003c:       e1a00003        mov     r0, r3
   10040:       e28dd010        add     sp, sp, #16   @ restore the stack pointer
   10044:       e1a0f00e        mov     pc, lr
```


## function parameter
```c
int foo(int p, int q, int r) {
  return p + q + r;
}

int main() {
  return foo(1, 3, 5);
}
```
- function `foo` has three parameters


```armasm
0001000c <foo>:
   1000c:       e24dd010        sub     sp, sp, #16
   10010:       e58d000c        str     r0, [sp, #12]    @ r0 has #1, int p
   10014:       e58d1008        str     r1, [sp, #8]     @ r1 has #3, int q
   10018:       e58d2004        str     r2, [sp, #4]     @ r2 has #5, int r
   1001c:       e59d200c        ldr     r2, [sp, #12]    @ r2 has #1
   10020:       e59d3008        ldr     r3, [sp, #8]     @ r3 has #3
   10024:       e0822003        add     r2, r2, r3       @ r2 has (p+q) -> 1+3
   10028:       e59d3004        ldr     r3, [sp, #4]     @ r3 has 5
   1002c:       e0823003        add     r3, r2, r3      @ r2 has ((1+3)+5), end of 'p+q+r'
   10030:       e1a00003        mov     r0, r3          @ save the value to the return value register, r0
   10034:       e28dd010        add     sp, sp, #16     @ restore the stack pointer
   10038:       e1a0f00e        mov     pc, lr          @ back to the calle

0001003c <main>:
   1003c:       e92d4010        push    {r4, lr}  @ why use r4?
   10040:       e3a02005        mov     r2, #5
   10044:       e3a01003        mov     r1, #3
   10048:       e3a00001        mov     r0, #1
   1004c:       ebffffee        bl      1000c <foo>
   10050:       e1a03000        mov     r3, r0    @ save the return value from foo()
   10054:       e1a00003        mov     r0, r3
   10058:       e8bd8010        pop     {r4, pc}
```

`sub sp, sp, #16`
- following AAPCS(ARM Architecture Procedure Call Standard), `sp` register should be aligned with 8-byte
- spill area: 16-byte
- because of `-O0` optimization.

`push {r4, lr}`
- why r4 is pushed?
- if only `lr` is pushed, 4-byte is used. That is not aligned 8-byte boundary.
- So push the dummy register, r4. 

> spill(str) & reload(ldr)
>
> spill: Save the register values to the memory in the stack.  
> reload: Get values from the memory into the register. 