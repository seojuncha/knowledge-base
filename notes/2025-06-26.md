# Compiler

## Lexical Analysis
드래곤 북의 lexical analysis 나머지 부분, transistion diagram이나 lexical analyzer generator부분은 정규표현식과 오토마타 개념을 익히고 이론적인 부분에는 도움이 될 지 모르지만, 실제 컴파일러 구현에는 크게 영향이 없으므로 가볍게 넘어갔다. 이제 실제 clang의 lexer를 살펴보면서 common lisp으로 lexer구현하기를 시작할 예정이다.

clang 의 lexer는 교재의 핵심 개념들을 어떤식으로 구현했는지 분석하면서 구현을 병행하면 좋을 것 같다.

> 추가로, 드래곤 북에서는 C언어의 전처리기(preprocessor)에 관해 다루지 않고 있다. 그 이유는 전처리기는 C언어의 자체적인 특성이지 컴파일러의 특성이 아니다. 그래서 lexer를 구현하면서 전처리기에 대한 구현도 함께 진행해야 한다. 

### 주요 포인트
- 버퍼링 처리는 어떻게 하고있나? 더블버퍼링은 실제 어떻게 구현하여 성능향상을 하는가?
- 버퍼의 lexer begin과 forward포인터들은 어떻게 관리하고 있나? lookahead기법을 적용하고 있나?
- 토큰 유형은 어떻게 분류하였나?
- 생성된 토큰들을 확인할 수 있는 방법은 있는가?
- identifier와 keyword의 분기 처리는 어떻게 하고 있나?
- preprocessor는 어떻게 구현되어 있고, lexer와 통합되어 있는가?
- 에러 처리는 어떻게 하고 있나?
- 연계된 #include 처리
- #define 처리, 어떻게 매크로 확장을 적용하나? 

### clang 관련 해야할 것
clang github저장소를 fork 하고 다음의 과정을 실습할 것.
- objc나 c++관련 분석에 불필요한 부분은 제거
- 직접 빌드하고 로그를 확인할 수 있어야 함
- 입력 문자열 스트림으로 부터 생성된 토큰을 확인할 수 있는 방법이 있는지 확인

아래 clang 명령어들 확인
| 명령                                  | 설명                                          |
| ----------------------------------- | ------------------------------------------- |
| `clang -Xclang -dump-tokens test.c` | **전처리까지 완료된 토큰**을 출력                        |
| `clang -E test.c`                   | 전처리 결과의 **소스 코드 문자열**을 출력 (`#include`가 확장됨) |
| `clang -fsyntax-only test.c`        | 전처리 및 구문 분석만 수행 (실행 파일 미생성)                 |
| `clang -cc1 -dump-raw-tokens`       | (실험적) **전처리 전 원시 토큰** 출력 (사용 어려움)           |


### 구현 검증
아래 방법들을 검토
- clang이 생성한 토큰과 비교
- 토큰 정보 중, 소스코드 위치와 관련된 정보가 일치하는지 비교
- 오류 및 경계값에 대한 검증

입력 소스 코드에 대한 토큰화를 검증하기 위한 자동화 스크립트도 구현해야 한다.

### 제약 사항
모든 기능을 제공하는 완벽한 C컴파일러를 만드는게 목적이 아니다. 우선 lexical analysis 관점에서 다음의 제약사항을 가정한다. 
- 유니코드 미지원
- 리터럴 문자 미지원
