
# Clang: Operator Precedence and Tokenization of Numeric Literals

## 1. Operator Precedence Handling

```cpp
namespace prec {
  enum Level {
    Unknown         = 0,  // Not binary operator.
    Comma           = 1,  // ,
    Assignment      = 2,  // =, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=
    Conditional     = 3,  // ?
    LogicalOr       = 4,  // ||
    LogicalAnd      = 5,  // &&
    InclusiveOr     = 6,  // |
    ExclusiveOr     = 7,  // ^
    And             = 8,  // &
    Equality        = 9,  // ==, !=
    Relational      = 10, // >=, <=, >, <
    Spaceship       = 11, // <=>
    Shift           = 12, // <<, >>
    Additive        = 13, // -, +
    Multiplicative  = 14, // *, /, %
    PointerToMember = 15  // .*, ->*
  };
}
```

### üîç Example Expression: `"1 + 1"`

- **LHS**: `'1'` (from `ParseAssignmentExpression`)
- **Parsing**: `ParseRHSOfBinaryExpression('1', prec::Assignment)`

```cpp
Parser::ParseRHSOfBinaryExpression(ExprResult LHS, prec::Level MinPrec) {
  // Tok = '+'
  prec::Level NextTokPrec = getBinOpPrecedence(
    Tok.getKind(), GreaterThanIsOperator, getLangOpts().CPlusPlus11
  ); // => prec::Additive

  if (NextTokPrec < MinPrec) // false
    return LHS;

  Token OpToken = Tok;   // Save '+'
  ConsumeToken();        // Advance to next token ('1')

  RHS = ParseCastExpression(CastParseKind::AnyCastExpr); // RHS = '1'

  prec::Level ThisPrec = NextTokPrec;

  NextTokPrec = getBinOpPrecedence(Tok.getKind(), GreaterThanIsOperator, getLangOpts().CPlusPlus11);
  // => prec::Unknown

  if (ThisPrec < NextTokPrec || (ThisPrec == NextTokPrec && isRightAssoc)) {
    // false
  }

  LHS = BinOp; // AST node: BinaryOperator('+', 1, 1)
}
```

### After `ParseAssignmentExpression()`

- `LHS = BinaryOperator('+', 1, 1)`
- Call `ParseRHSOfBinaryExpression(LHS, prec::Comma)`

```cpp
NextTokPrec = prec::Unknown;
if (NextTokPrec < MinPrec) // (Unknown < Comma) => true
  return LHS;              // return LHS (binary operator AST)
```

---

## 2. Tokenizing Continuous Numeric Literals

### üîç Example: `"12+2"`

```cpp
bool Lexer::LexTokenInternal(Token &Result, bool TokAtPhysicalStartOfLine) {
  const char *CurPtr = BufferPtr;

  switch (*CurPtr) {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      return LexNumericConstant(Result, CurPtr);
  }
}
```

### LexNumericConstant

```cpp
bool Lexer::LexNumericConstant(Token &Result, const char *CurPtr) {
  unsigned Size;
  char C = getCharAndSize(CurPtr, Size); // C = '1'
  char PrevCh = 0;

  while (isPreprocessingNumberBody(C)) { // Checks [a-zA-Z0-9_.]
    CurPtr = ConsumeChar(CurPtr, Size, Result); // '1', '2'
    PrevCh = C;
    C = getCharAndSize(CurPtr, Size); // Stop at '+'
  }

  const char *TokStart = BufferPtr; // Start at '1'
  FormTokenWithChars(Result, CurPtr, tok::numeric_constant); // Length = 2
  Result.setLiteralData(TokStart);
}
```

### FormTokenWithChars

```cpp
void FormTokenWithChars(Token &Result, const char *TokEnd, tok::TokenKind Kind) {
  unsigned TokLen = TokEnd - BufferPtr; // 2
  Result.setLength(TokLen);
  Result.setLocation(getSourceLocation(BufferPtr, TokLen)); // range 0~2
  Result.setKind(Kind);
  BufferPtr = TokEnd; // Move past "12"
}
```

---

## ‚úÖ Summary

- `ParseRHSOfBinaryExpression` recursively builds BinaryOperator ASTs based on precedence levels.
- `LexNumericConstant` reads consecutive numeric characters into a single `numeric_constant` token.

