# Compiler

## clang; parsing statements

Related methods
```cpp
  /// A SmallVector of statements.
  typedef SmallVector<Stmt *, 24> StmtVector;

    /// Flags describing a context in which we're parsing a statement.
  enum class ParsedStmtContext {
    /// This context permits declarations in language modes where declarations
    /// are not statements.
    AllowDeclarationsInC = 0x1,
    /// This context permits standalone OpenMP directives.
    AllowStandaloneOpenMPDirectives = 0x2,
    /// This context is at the top level of a GNU statement expression.
    InStmtExpr = 0x4,

    /// The context of a regular substatement.
    SubStmt = 0,
    /// The context of a compound-statement.
    Compound = AllowDeclarationsInC | AllowStandaloneOpenMPDirectives,

    LLVM_MARK_AS_BITMASK_ENUM(InStmtExpr)
  };

  StmtResult
  ParseStatement(SourceLocation *TrailingElseLoc = nullptr,
                 ParsedStmtContext StmtCtx = ParsedStmtContext::SubStmt);

  StmtResult
  ParseStatementOrDeclaration(StmtVector &Stmts, ParsedStmtContext StmtCtx,
                              SourceLocation *TrailingElseLoc = nullptr);

  StmtResult ParseExprStatement(ParsedStmtContext StmtCtx);

    StmtResult ParseReturnStatement();
```

- ParseStatement
- ParseStatementOrDeclaration
- ParseStatementOrDeclarationAfterAttributes
  - Return StmtResult 

```cpp
StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(
    StmtVector &Stmts,
    ParsedStmtContext StmtCtx,
    SourceLocation *TrailingElseLoc,
    ParsedAttributes &CXX11Attrs,     // Don't need
    ParsedAttributes &GNUAttrs) {     // Don't need
  StmtResult Res;    // Final output

  // Get the token kind of the current token.
  tok::TokenKind Kind  = Tok.getKind();
  switch (Kind) {
    case tok::identifier:
      Token Next = NextToken();
    case tok::l_brace:                // C99 6.8.2: compound-statement
      return ParseCompoundStatement();
    case tok::semi: {                 // C99 6.8.3p3: expression[opt] ';'
      bool HasLeadingEmptyMacro = Tok.hasLeadingEmptyMacro();
      return Actions.ActOnNullStmt(ConsumeToken(), HasLeadingEmptyMacro);
    }
    case tok::kw_return:              // C99 6.8.6.4: return-statement
      Res = ParseReturnStatement();
      SemiError = "return";
      break;
  }

    // If we reached this code, the statement must end in a semicolon.
  if (!TryConsumeToken(tok::semi) && !Res.isInvalid()) {
    // If the result was valid, then we do want to diagnose this.  Use
    // ExpectAndConsume to emit the diagnostic, even though we know it won't
    // succeed.
    ExpectAndConsume(tok::semi, diag::err_expected_semi_after_stmt, SemiError);
    // Skip until we see a } or ;, but don't eat it.
    SkipUntil(tok::r_brace, StopAtSemi | StopBeforeMatch);
  }

  return Res;
}
```

```cpp
StmtResult Parser::ParseReturnStatement() {
  ExprResult R;
  R = ParseExpression();
  return Actions.ActOnReturnStmt(ReturnLoc, R.get(), getCurScope());
}
```

```cpp
StmtResult Sema::ActOnReturnStmt(SourceLocation ReturnLoc,
                      Expr *RetValExp,
                      Scope *CurScope) {
  ExprResult RetVal = RetValExp;
  StmtResult R =
    BuildReturnStmt(ReturnLoc, RetVal.get(), /*AllowRecovery=*/true);
  return R;
}
```

AST for `return`
**include/clang/AST/Stmt.h**
```cpp
// return;
// return 4;
class ReturnStmt {
    Stmt *RetExpr;
}
```


How to distinguish between an identifier and a keyword?

### Identifier and Keywords in Lexing
- `IdentifierTable`
```cpp
// Make a has table.
IdentifierTable::IdentifierTable(IdentifierInfoLookup *ExternalLookup)
    : HashTable(8192), // Start with space for 8K identifiers.
      ExternalLookup(ExternalLookup) {}

// Then, fill language keywords into the hash table first.
IdentifierTable::IdentifierTable(const LangOptions &LangOpts,
                                 IdentifierInfoLookup *ExternalLookup)
    : IdentifierTable(ExternalLookup) {
  // Populate the identifier table with info about keywords for the current
  // language.
  AddKeywords(LangOpts);
}

/// AddKeywords - Add all keywords to the symbol table.
void IdentifierTable::AddKeywords(const LangOptions &LangOpts) {
#define KEYWORD(NAME, FLAGS) \
  AddKeyword(StringRef(#NAME), tok::kw_ ## NAME,  \
             FLAGS, LangOpts, *this);

#define ALIAS(NAME, TOK, FLAGS) \
  AddKeyword(StringRef(NAME), tok::kw_ ## TOK,  \
             FLAGS, LangOpts, *this);

#include "clang/Basic/TokenKinds.def"
}

```
Define Keyword tokens.
**clang/Basic/TokenKinds.def**
```cpp
#ifndef TOK
#define TOK(X)

#ifndef KEYWORD
#define KEYWORD(X,Y) TOK(kw_ ## X)

KEYWORD(int                         , KEYALL)
KEYWORD(return                      , KEYALL)
//...
```
- KEYWORD(int, KEYALL)
  - TOK(kw_int)


```cpp
static void AddKeyword(StringRef Keyword,           // e.g) "return"
                       tok::TokenKind TokenCode,    // e.g) kw_return
                       unsigned Flags,
                       const LangOptions &LangOpts,
                       IdentifierTable &Table) {
  IdentifierInfo &Info =
    Table.get(Keyword, AddResult == KS_Future ? tok::identifier : TokenCode);
  // Just Table.get(Keyword, TokenCode) for me!
}

// Name: "return"
// TokenCode: kw_return
IdentifierInfo &get(StringRef Name, tok::TokenKind TokenCode) {
  IdentifierInfo &II = get(Name);
  II.TokenID = TokenCode;
  assert(II.TokenID == (unsigned) TokenCode && "TokenCode too large");
  return II;
}

// Name: "return"
/// Return the identifier token info for the specified named identifier.
IdentifierInfo &get(StringRef Name) {
  auto &Entry = *HashTable.try_emplace(Name, nullptr).first;

  IdentifierInfo *&II = Entry.second;
  if (II) return *II;

  // Lookups failed, make a new IdentifierInfo.
  void *Mem = getAllocator().Allocate<IdentifierInfo>();
  II = new (Mem) IdentifierInfo();

  // Make sure getName() knows how to find the IdentifierInfo
  // contents.
  II->Entry = &Entry;

  return *II;
}
```

What is the `HashTable` in here?
- Just a map, key: string, value: custom allocator

While `Lexing`,
- Related method: `Lexer::LexIdentifierContinue`
- First, get a sequence of ascii characters
- Second, lookup by `LookUpIdentifierInfo`

```cpp

IdentifierInfo *Preprocessor::LookUpIdentifierInfo(Token &Identifier) const {
  IdentifierInfo *II;
  II = getIdentifierInfo(Identifier.getRawIdentifier());

  Identifier.setIdentifierInfo(II);
  Identifier.setKind(II->getTokenID());

  return II;
}

IdentifierInfo *getIdentifierInfo(StringRef Name) const {
  return &Identifiers.get(Name);  //  mutable IdentifierTable Identifiers; 
}

```


## So.. TODO
- Lex
  - Define Identier Table
  - Register keywords into the table
  - More lex for identifiers to distinguish if it is an identifer or a keyword
- Parse
  - parse-statement
  - parse-return-statement