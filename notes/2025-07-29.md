# Compiler

## Clang CodeGen Flow Summary 

```cpp
void clang::ParseAST(Sema &S, bool PrintStats, bool SkipFunctionBodies) {
  for (bool AtEOF = P.ParseFirstTopLevelDecl(ADecl, ImportState); !AtEOF;
       AtEOF = P.ParseTopLevelDecl(ADecl, ImportState)) {
    if (ADecl && !Consumer->HandleTopLevelDecl(ADecl.get()))
      return;
  }
  Consumer->HandleTranslationUnit(S.getASTContext());
}
```

```cpp
bool BackendConsumer::HandleTopLevelDecl(DeclGroupRef D) {
  Gen->HandleTopLevelDecl(D);
}
```

```cpp
class CodeGeneratorImpl : public CodeGenerator {
protected:
  std::unique_ptr<CodeGen::CodeGenModule> Builder;
public:
  bool HandleTopLevelDecl(DeclGroupRef DG) override {
    for (auto &I : DG)
      Builder->EmitTopLevelDecl(I);
  }
};
```

```cpp
void CodeGenModule::EmitTopLevelDecl(Decl *D) {
  switch (D->getKind()) {
    case Decl::Function:
      EmitGlobal(cast<FunctionDecl>(D));
  }
}
```

```cpp
void CodeGenModule::EmitGlobal(GlobalDecl GD) {
  if (MustBeEmitted(Global) && MayBeEmittedEagerly(Global)) {
    EmitGlobalDefinition(GD);
    addEmittedDeferredDecl(GD);
    return;
  }
}
```

```cpp
void CodeGenModule::EmitGlobalDefinition(GlobalDecl GD, llvm::GlobalValue *GV) {
  return EmitGlobalFunctionDefinition(GD, GV);
}
```

```cpp
void CodeGenModule::EmitGlobalFunctionDefinition(GlobalDecl GD, llvm::GlobalValue *GV) {
  const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(GD);
  auto *Fn = cast<llvm::Function>(GV);
  CodeGenFunction(*this).GenerateCode(GD, Fn, FI);
}
```

```cpp
void CodeGenFunction::GenerateCode(GlobalDecl GD, llvm::Function *Fn, const CGFunctionInfo &FnInfo) {
  FunctionArgList Args;
  QualType ResTy = BuildFunctionArgList(GD, Args);
  Stmt *Body = FD->getBody();
  StartFunction(GD, ResTy, Fn, FnInfo, Args, Loc, BodyRange.getBegin());
  EmitFunctionBody(Body);
  FinishFunction(BodyRange.getEnd());
}
```

```cpp
void CodeGenFunction::EmitFunctionBody(const Stmt *Body) {
  if (const CompoundStmt *S = dyn_cast<CompoundStmt>(Body))
    EmitCompoundStmtWithoutScope(*S);
  else
    EmitStmt(Body);
}

void CodeGenFunction::EmitStmt(const Stmt *S, ArrayRef<const Attr *> Attrs) {
  switch (S->getStmtClass()) {
    case Stmt::ReturnStmtClass:  EmitReturnStmt(cast<ReturnStmt>(*S));      break;
  }
}

void CodeGenFunction::EmitReturnStmt(const ReturnStmt &S) {
   // Emit the result value, even if unused, to evaluate the side effects.
  const Expr *RV = S.getRetValue();
  switch (getEvaluationKind(RV->getType())) {
    case TEK_Scalar: {
      llvm::Value *Ret = EmitScalarExpr(RV);
      auto *I = Builder.CreateStore(Ret, ReturnValue);  // Address ReturnValue is a member varaible
      addInstToCurrentSourceAtom(I, I->getValueOperand());
    }
  }
}
```

**DAG Selection (ISEL)**
```cpp
bool InstructionSelect::selectMachineFunction(MachineFunction &MF) {
  // DAG to MachineInstr selection
}
```

**Final Assembly Output (AsmPrinter)**
- Converts MachineInstr to text assembly for the target.

Example Breakdown
```
AST
└── Function
    └── ReturnStmt → mov r0, t3
        └── BinaryOperator → t3 = t1 + t2
            ├── IntegerLiteral → t1 = 3  → #3
            └── IntegerLiteral → t2 = 5  → #5

StartFunction:
  sub sp, sp, #4

EmitFunction:
main:
  mov r0, #8
  add sp, sp, #4
  bx lr
```
