# ARM Assembly
어셈블리를 직접 작성해서 qemu로 실행하고 레지스터를 확인하기. (완료)

ELF 파일은 링커스크립트로 시작주소를 정해줘야 한다. 하지만 as 를 직접 실행하기 위해선 elf 포맷이 아니라 flat binary로 만들어야 한다. 이유는 뭘까?

- qemu-system-arm은 전체 시스템을 부팅하는 방식임 따라서, 부트로더->커널로 이어지는 실행과정.
qemu는 장치(-machine)의 시작주소에 -kernel옵션의 코드를 로딩한다.
- `-kernel` 옵션의 인자가 elf포맷인 경우, 먼저 elf헤더를 파싱할 해서 시작주소를 얻는다.
.text 섹션의 실행코드를 시작주소에 로딩.
- `-kernel` 옵션의 인자가 bin포맷인 경우, 장치에서 정해진 시작주소에 해당 바이너리를 바로 로드시킨다.
따라서 바이너리 자체에 별도의 시작주소를 설정해줄 필요가 없다.
  => *그럼 qemu는 입력파일의 포맷을 검사하나? 코드로 확인해볼 것!*
- 일종의 부트로더를 실행하는 방식임

```armasm
  .text
  .global _start
_start:
  mov r1, #3
  mov r2, #4
  add r0, r1, r2
  b .
```

Compile it
```bash
# include .org
arm-none-eabi-as -march=armv5te -o main.o main.s
# not include .org
arm-none-eabi-as -march=armv5te -o main.o main.s
arm-none-eabi-ld -A armv5te -Ttext=0x10000 -o main.elf main.o
arm-none-eabi-ld -A armv5te -o main.elf main.o
```

Flatten
```bash
$ arm-none-eabi-objcopy -O binary main.elf main.bin
```

check the binary file
```bash
$ xxd main.bin
00000000: 0310 a0e3 0420 a0e3 0200 81e0 feff ffea 
```

Run qemu
```bash
# run flat binary
$ qemu-system-arm -machine versatilepb -nographic -kernel main.bin -S -s
# run elf
$ qemu-system-arm -machine versatilepb -nographic -kernel main.elf -S -s
```

Run `gdb-multiarch`
```bash
$ gdb-multiarch main.elf
(gdb) target remote :1234
(gdb) break _start  # or break *0x10000
(gdb) continue
(gdb) i r r0 r1 r2 pc
```

## `.org` directive
- short for `origin`
- specefies the starting memory address or offest
- set the location counter

### compare two assembly files and binaries

**without_org.s**
```armasm
  .text
  .global _start
_start:
  b .
```

**with_org.s**
```armasm
  .text
  .org 0x10
  .global _start
_start:
  b .
```
```bash
$ xxd without_org.bin
00000000: feff ffea                                ....
```

```bash
$ xxd with_org.bin
00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000010: feff ffea                                ....
      ^ set by .org directive
```

## Set asddress With a linker
- linker:
  - 메모리 주소 결정
- .org:
  - 섹션의 오프셋 결정

링커가 사용하는 링커스크립트 확인하기
```bash
$ arm-none-eabi-ld --verbose ...
```

## Fro convineint .bashrc
```bash
alias agcc='arm-none-eabi-gcc'
alias ald='arm-none-eabi-ld'
alias aas='arm-none-eabi-as'
alias areadelf='arm-none-eabi-readelf'
```

## branch instruction
- instructions:
  - b label
    - (unconditionally) branch to label
  - bl label
    - subroutine call to function
- stores a return address in the linke register(r14/lr)
- registers:
  - r15(pc)
  - r14(lr)

### How to sue the `LR` register? What is it?

**main.c**
```c
void foo(void) {
}

int main(void) {
  foo();
  return 0;
}
```

Compile
```bash
$ arm-none-eabi-gcc -marm -march=armv4 -O0 -S main.c -o main.s
$ arm-none-eabi-as -march=armv4 -o main.o main.s
$ arm-none-eabi-ld -A armv4 -Ttext=0x10000 main.o -o main.elf
```

Check `.text` section
```bash
$ arm-none-eabi-objdump -h .text -d main.elf
```

### Hack with QEMU.
```bash
# flatten
$ arm-none-eabi-objcopy -O binary main.elf main.bin
# run qemu
$ qemu-system-arm -machine versatilepb -kernel main.bin -nographic -S -s
```

### branch test
```armasm
  .text
  .global _start @ .global을 해주지 안으면 링커가 _start를 찾지 못함.
_start:
  mov r1, #3
  bl foo   @ save lr? lr=pc+4? => OK.
  mov r1, r0
  b .
foo:
  add r1, r1, #2
  mov r0, r1
  bx lr   @ armv4t 이상부터 지원.
```

### push-pop test
```armasm
  .text
  .global _start
_start:
  mov sp, 0x10000  @ important !!
  mov r0, #3
  mov r1, #2
  bl foo
  mov r1, r0  @ r1=3, r0=3
  b .
foo:
  push {r0, r1, lr}  @ r0=3, r1=2, sp=0xfff4 (hex(0x10000-12) from high to low
  mov r0, #1     @ r0=1, but r0 will be ignored in _start becasue of POP
  pop {r0, r1, pc}
```

```bash
$ arm-none-eabi-as -march=armv4 -o main.o main.s
$ arm-none-eabi-ld -A armv4 -Ttext=0x10000 main.o -o main.elf
$ arm-none-eabi-objcopy -O binary main.elf main.bin
$ qemu-system-arm -machine versatilepb -kernel main.bin -nographic -S -s
```

```bash
$ gdb-multiarch main.elf
(gdb) target remote :1234
(gdb) i r pc lr sp r0 r1
```