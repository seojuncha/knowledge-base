## ARM Assembly

### data movement

**main.c**
```c
int main(void) {
  int a = 5;
  int b = a;
  return b;
}
```

**Compile**
```bash
$ arm-none-eabi-gcc -nostdlib -fomit-frame-pointer -marm -march=armv4 -O0 -S main.c -o main.s
$ arm-none-eabi-as -march=armv4 start.s main.s -o main.o
$ arm-none-eabi-ld -A armv4 -T link.ld main.o -o main.elf
$ arm-none-eabi-objcopy -O binary main.elf main.bin
```

### offset vs pre-index vs post-index
- offset
  - calculate offset
  - access to the calculated memory address
  - e.g) `LDR r0, [r3, #2]`  @ load from R3+2, not update R3
- pre-index
  - offset calculation
  - access to the calculated memory address
  - then update registers
  - e.g) `LDR r0, [r3, #2]!`  @ load from R3+2, then R3=R3+2
- post-index
  - access to the memory address
  - offset calculation and update registers
  - e.g) `LDR r0, [r3] #2`   @ load from R3, then R3=R3+2

**main.s**
```armasm
main:
  sub sp, sp, #8    @ function prologue

  mov r3, #5        @ int a = 5
  str r3, [sp, #4]
  ldr r3, [sp, #4]

  str r3, [sp]      @ int b = a
  ldr r3, [sp]

  mov r0, r3        @ return b

  add sp, sp, #8    @ function epilogue
  mov pc, lr

```

Only assembly file
```armasm
  .text
  .global _start
_start:
  mov sp, #0x10000
  bl main
  b .
main:
  sub sp, sp, #4

  mov r1, #9
  str r1, [sp]
  ldr r0, [sp]

  add sp, sp, #4
  mov pc, lr
```

Compile
```bash
$ arm-none-eabi-as -march=armv4 main.s -o main.o
$ arm-none-eabi-ld -A armv4 -Ttext=0x10000 main.o -o main.elf
$ arm-none-eabi-objcopy -O binary main.elf main.bin
```

Run qemu
```bash
$ qemu-system-arm -machine versatilepb -kernel main.bin -nographic -S -s
```